import os
import json
import logging
import re
from openai import OpenAI
from dotenv import load_dotenv

# Load API Key
load_dotenv()
client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))

# Configure Logging
LOG_FILE = "strategy_errors.log"
DEBUG_FILE = "strategy_debug.json"

logging.basicConfig(
    filename=LOG_FILE,
    level=logging.ERROR,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

def sanitize_json_response(response_text):
    """Removes unwanted characters (e.g., Markdown formatting) from the JSON response."""
    # Remove Markdown code block markers (e.g., ```json ... ```)
    response_text = re.sub(r"```json\s*|\s*```", "", response_text).strip()
    return response_text

def convert_risk_management_values(strategy_json):
    """Ensures risk management values are numerical or percentages."""
    if "risk_management" in strategy_json:
        for key in ["stop_loss", "take_profit", "position_size"]:
            # If the user left it out or set it to null, skip converting
            if key not in strategy_json["risk_management"]:
                continue  # no key => skip
            value = strategy_json["risk_management"][key]
            if value is None:
                # Option A: skip if it's None 
                # (so you can handle it with a default in your build_strategy_class)
                continue  

                # or Option B: set to 0 or some default
                # strategy_json["risk_management"][key] = 0.0
                # continue

            try:
                # The existing logic: handle e.g. "5%", "10" 
                if isinstance(value, str) and value.endswith('%'):
                    strategy_json["risk_management"][key] = float(value.strip('%')) / 100.0
                else:
                    strategy_json["risk_management"][key] = float(value)
            except ValueError:
                raise ValueError(f"Invalid numeric value for {key}: {value}")
    return strategy_json

class ChatGPTAPI:
    """
    A class for interfacing with ChatGPT to generate JSON-based responses
    for trading strategies and stock screeners.
    """

    def __init__(self, model_name="gpt-4o-mini"):
        """
        :param model_name: The name of the OpenAI model to use.
        """
        self.model_name = model_name

    def _send_request(self, system_prompt, user_input, chat_history=None):
        """
        Internal helper to send a request to the ChatGPT API and parse the JSON response.
        """
        messages = [{"role": "system", "content": system_prompt}]

        # If chat history exists, include it
        if chat_history and isinstance(chat_history, list):
            messages.extend(chat_history)

        # Add user's latest request
        messages.append({"role": "user", "content": user_input})

        try:
            print(f"üìå Debug: Sending request to OpenAI API using `{self.model_name}`...")
            response = client.chat.completions.create(
                model=self.model_name,
                messages=messages
            )

            # Extract API response content
            raw_text = response.choices[0].message.content.strip()
            print(f"üìå Debug: Raw API Response:\n{raw_text}")

            # Save raw response to a debug file
            with open(DEBUG_FILE, "a", encoding="utf-8") as debug_file:
                debug_file.write(raw_text + "\n")

            # Sanitize JSON
            clean_text = sanitize_json_response(raw_text)
            parsed_json = json.loads(clean_text)
            return parsed_json

        except json.JSONDecodeError:
            error_message = "Invalid JSON format generated by ChatGPT."
            logging.error(error_message)
            print(f"‚ùå Debug: {error_message}")
            return {"error": error_message}

        except Exception as e:
            error_message = f"API request failed: {str(e)}"
            logging.error(error_message)
            print(f"‚ùå Debug: {error_message}")
            return {"error": error_message}

    def generate_trading_strategy(self, user_input, chat_history=None):
        """
        Generates a structured trading strategy JSON using ChatGPT based on user input.
        Returns a dict with fields like:
            "strategy_name", "description", "indicators", "entry_condition", "exit_condition", "risk_management"
        """
        print("üìå Debug: Starting strategy generation...")

        system_prompt = """You are an expert in algorithmic trading strategy generation. 
        Your goal is to produce structured JSON strategies based on user input, formatted correctly for execution in our Backtrader trading system.

        üöÄ IMPORTANT:
        1) Respond **ONLY** with a valid JSON object. Do NOT wrap it in markdown code fences or add any additional text or disclaimers.
        2) The JSON must follow **exactly** the schema below, with the field names and data types we specify.
        3) Do not include extra fields or nested objects beyond what is specified.

        ## JSON Schema

        {
        "strategy_name": "<String: descriptive name>",
        "description": "<String: short explanation of the strategy>",
        "entry_logic": {
            "operator": "<String: 'any' or 'all'>",
            "conditions": [
            {
                "type": "<One of: RSI, MACD, Momentum, SMA, EMA, Stochastic, WMA, DEMA, TEMA, SMMA, HMA, KAMA, ZLEMA, ROC, RVI, TRIX, CCI, UO, AO, PPO, ATR, BOLLINGER, BBANDS, NATR, ADX, ADXR, PLUS_DI, MINUS_DI, PLUS_DM, MINUS_DM, SAR, OBV, MFI, AROON, AROONOSC, HEIKINASHI, ICHIMOKU, HOLP, LOLP>",
                "parameters": {
                // Indicator-specific parameters
                },
                "condition": "<One of: '>', '<', '>=', '<=', 'cross_above', 'cross_below'>",
                "value":  <Numeric or null>,
                "reference": "<Optional: e.g., 'PRICE', 'SignalLine', or another indicator>",
                "reference_parameters": { 
                // Optional: numeric parameters for the reference, e.g. another MACD or something
                }
            }
            ]
        },
        "exit_logic": {
            "operator": "<String: 'any' or 'all'>",
            "conditions": [
            {
                "type": "<One of: RSI, MACD, ... same as above>",
                "parameters": { /* numeric params */ },
                "condition": "<One of: '>', '<', '>=', '<=', 'cross_above', 'cross_below'>",
                "value": <Numeric or null>,
                "reference": "<Optional>",
                "reference_parameters": { /* numeric params if referencing an indicator */ }
            }
            ]
        },
        "risk_management": {
            "stop_loss": <Numeric (like 5 = 5%)>,
            "take_profit": <Numeric (like 10 = 10%)>,
            "position_size": <Numeric (like 0.5 for 50% of capital, or 100 for 100 shares)>
        }
        }

        - For the following moving average indicators, use only the specified parameters. These indicators do not use internal reference lines like a SignalLine, UpperBand, etc. If you want to compare them to another price or indicator, use the "reference" field with "PRICE" or another indicator type.

            SMA:
                - Parameters: "period"
                - Reference: "PRICE" (e.g., close price) or another indicator
            EMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator
            WMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator
            DEMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator
            TEMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator
            SMMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator
            HMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator
            ZLEMA:
                - Parameters: "period"
                - Reference: "PRICE" or another indicator

        - These indicators produce a single line and are often compared against the price, or used in crossovers against another instance of the same type with a different period.
        - If using a crossover condition (e.g., cross_above), the reference must be another indicator or "PRICE".
        - Do NOT include extra parameters such as "fastperiod", "slowperiod", "dev", "factor", etc., unless explicitly documented for that specific indicator.
        
        - The following indicators support specific parameters and comparisons. Use these strictly when building strategy JSONs:

            RSI (Relative Strength Index):
                - Parameters: "period"
                - Common usage: compare to numeric values (e.g., RSI < 30, RSI >= 70)
                - Reference: not needed or set to "PRICE" if comparing to price

            MACD (Moving Average Convergence Divergence):
                - Parameters: "period_me1", "period_me2", "period_signal"
                - Common usage: "cross_above" or "cross_below" against reference: "SignalLine"
                - Reference: set to "SignalLine" when doing crossovers

            STOCH (Stochastic Oscillator):
                - Parameters: "period", "period_dfast", "period_dslow"
                - Common usage: %K vs %D crossovers; e.g., cross_above reference "SignalLine"
                - Reference: use "SignalLine" for %K vs %D
                - `"percD"` and `"percK"` can also be used explicitly

            MOMENTUM:
                - Parameters: "period"
                - Common usage: compare to numeric value (e.g., > 0 or < 0)
                - Reference: not typically needed, or "PRICE"

            ROC (Rate of Change):
                - Parameters: "period"
                - Common usage: compare to 0 (e.g., ROC > 0 or ROC < 0)
                - Reference: "PRICE" or null

            TRIX:
                - Parameters: "period"
                - Common usage: "cross_above" or "cross_below" a zero line
                - Reference: optional; set to 0 or null

            CCI (Commodity Channel Index):
                - Parameters: "period"
                - Common usage: CCI < -100 to buy, > 100 to sell
                - Reference: not needed

            UO (Ultimate Oscillator):
                - Parameters: "p1", "p2", "p3", "upperband", "lowerband"
                - Common usage: UO < 30 to buy, > 70 to sell
                - Reference: not needed

            AO (Awesome Oscillator):
                - Parameters: none (uses default fast and slow periods)
                - Common usage: "cross_above" or "cross_below" 0
                - If doing crossovers with 0 line, set "reference" to null and "value" to 0

            PPO (Percentage Price Oscillator):
                - Parameters: "period1", "period2", "period_signal"
                - Common usage: "cross_above" or "cross_below" reference: "SignalLine"
                - Reference: "SignalLine"

        - These indicators have specific parameters and typical usage conventions:

            ATR (Average True Range):
                - Parameters: "period"
                - Common usage: can be used in numeric comparisons (e.g., ATR > 2)
                - Reference: not typically used

            BOLLINGER:
                - Parameters: "period", "devfactor"
                - Reference: can be "LowerBand", "UpperBand" or "MiddleBand"
                - Usage: price < LowerBand for buy, price > UpperBand for sell
                - Avoid using "dev" or "stdev" as parameters ‚Äî only use "devfactor"

            BBANDS:
                - Parameters: "period", "devfactor"
                - Same usage as BOLLINGER
                - Reference: can be "LowerBand", "UpperBand" or "MiddleBand"
                - Often used with crossover to or comparison against the bands

            ADX (Average Directional Index):
                - Parameters: "period"
                - Usage: ADX > threshold (e.g., > 20) to detect strong trends
                - Reference: not required

            ADXR (Average Directional Movement Rating):
                - Parameters: "period"
                - Usage: similar to ADX, used for trend strength filtering
                - Reference: not required

            PLUS_DI (Plus Directional Indicator):
                - Parameters: "period"
                - Usage: crossover with MINUS_DI or numeric thresholds
                - Reference: can be "MINUS_DI" for comparison

            MINUS_DI (Minus Directional Indicator):
                - Parameters: "period"
                - Usage: can be used in crossover with PLUS_DI or numeric value
                - Reference: can be "PLUS_DI"

            SAR (Parabolic SAR):
                - Parameters: "af" (acceleration factor), "afmax"
                - Usage: "cross_above" or "cross_below" vs "PRICE" to detect trend reversals
                - Reference: use "PRICE" ‚Äî avoid "SAR" unless comparing SAR to another SAR

            AROONUPDOWN:
                - Parameters: "period"
                - Usage: compares AROON Up and Down for trend direction
                - Reference: can be `"AROONDOWN"` or `"AROONUP"

            AROONOSC:
                - Parameters: "period"
                - Usage: compare AROONOSC to numeric values (e.g., > 0)
                - Reference: optional, usually null

            HEIKINASHI:
                - Parameters: none
                - Usage: Typically used as a filter (e.g., bullish/bearish candle), not for numeric comparisons.
                - Reference: "PRICE" if comparing to price direction.
                - Use one of the following:
                    - "condition": ">" or "<", "reference": "PRICE" to detect bullish/bearish trend
                    - Avoid null conditions ‚Äî do not use "condition": null

            ICHIMOKU:
                - Parameters: "tenkan", "kijun", "senkou"
                - Usage: crossover between lines (e.g., Tenkan > Kijun)
                - Reference: "Tenkan", "Kijun", "SenkouA" or "SenkouB"
                - Common strategies: Tenkan crosses above Kijun to buy
            

        ### Additional Rules

        - When setting the "operator" key, you must only use either "any" or "all". Do not use "cross_above" or "cross_below" (or any other strings) for the operator value.
        - The "operator" key can only be "any" or "all".
        - If the user references MACD, use ‚Äúperiod_me1‚Äù, ‚Äúperiod_me2‚Äù, and ‚Äúperiod_signal‚Äù instead of fastperiod/slowperiod/signalperiod.
        - When generating a strategy using PPO, use parameter names  period1, period2 and period_signal.
        - For indicators like RSI that require only one period parameter, include only a single key named "period" and do not add any extra keys (such as "period_dfast" or "period_dslow").
        - When creating a STOCH condition, use param names: period, period_dfast, period_dslow (if needed), instead of fastk_period or fastd_period.
        - When referencing a SAR crossover with price, please set "type": "SAR" and "reference": "PRICE". Avoid "reference": "SAR", unless you truly want to compare two separate indicators.
        - When generating a Bollinger strategy, use "period" for the window size and "devfactor" for the standard deviation multiplier. Avoid using keys like dev or stdev.
        - For crossover strategies, prefer using 'cross_above' or 'cross_below' over just '>' or '<' unless the strategy intentionally holds.
        - Avoid null 'condition' fields. Every condition must include a logical operation, even for candles (e.g., '>' vs 'PRICE').
        - If using dual conditions (e.g. AROON or DI cross strategies), consider making one optional or using 'any' for the operator.
        - This new format **replaces** any older fields like "entry_condition" or "exit_condition". Now we have "entry_logic" and "exit_logic" with an operator and an array of conditions.
        - No disclaimers or instructions. Only raw JSON that conforms to the schema.
        
        ###
        Example

        {
        "strategy_name": "RSI MACD Strategy",
        "description": "Buys if RSI < 30 or MACD crosses above its signal. Sells if RSI >= 70.",
        "entry_logic": {
            "operator": "any",
            "conditions": [
            {
                "type": "RSI",
                "parameters": {"period": 14},
                "condition": "<",
                "value": 30
            },
            {
                "type": "MACD",
                "parameters": {"period_me1":12, "period_me2":26, "period_signal":9},
                "condition": "cross_above",
                "value": null,
                "reference": "SignalLine",
                "reference_parameters": {}
            }
            ]
        },
        "exit_logic": {
            "operator": "all",
            "conditions": [
            {
                "type": "RSI",
                "parameters": {"period": 14},
                "condition": ">=",
                "value": 70
            }
            ]
        },
        "risk_management": {
            "stop_loss": 5,
            "take_profit": 10,
            "position_size": 0.05
        }
        }

        AGAIN: Respond ONLY with the raw JSON. Do not wrap in code fences or provide extra text.

        """

        parsed_json = self._send_request(system_prompt, user_input, chat_history)

        if "error" in parsed_json:
            return parsed_json  # Return error dict

        # Convert numeric values in risk management
        try:
            parsed_json = convert_risk_management_values(parsed_json)
        except ValueError as e:
            return {"error": str(e)}

        print("‚úÖ Debug: Successfully parsed and validated JSON strategy.")
        return parsed_json

    def generate_stock_screener(self, user_input, chat_history=None):
        """
        Generates a structured stock screening JSON using ChatGPT based on user input.
        Returns a dict with a top-level "criteria" field, e.g.:
        {
          "criteria": {
             "sector": "Technology",
             "pe_ratio": { "max": 20 },
             "revenue_growth_yoy": { "min": 5 },
             "dividend_yield": { "min": 3 }
          }
        }
        """
        print("üìå Debug: Starting stock screener generation...")

        # System prompt specifically for screening
        system_prompt = """You are an expert in stock screening and fundamental analysis.
        The user will describe their screening criteria in plain English, and you will respond with a valid JSON object
        that only includes a top-level "criteria" field specifying numeric or textual filters.

        Example output format:
        {
            "criteria_name": "<String: descriptive name>",
            "description": "<String: short explanation of the Criteria>",
            "criteria": {
                "sector": "Technology",
                "pe_ratio": {"max": 20},
                "revenue_growth_yoy": {"min": 5},
                "dividend_yield": {"min": 3}
          }
        }

        üöÄ **IMPORTANT**: Respond **ONLY** with a valid JSON object, **no additional text or markdown** before or after the JSON.

        ‚ö° **Numeric Fields** you might produce:
        - pe_ratio, revenue_growth_yoy, dividend_yield, market_cap, etc.
        - each one can have {"min": X} or {"max": Y} or both
        - e.g. "pe_ratio": {"max": 20}, "market_cap": {"min": 1000000000}

        ‚ö° **String Fields** you might produce:
        - sector
        - exchange
        - industry

        If the user includes any conditions that don't fit a numeric or textual field, politely ignore them or leave them out.

        **DO NOT** include extra keys (like risk management). 
        **DO NOT** add explanations or disclaimers‚Äîonly return the raw JSON object with "criteria".
        """

        parsed_json = self._send_request(system_prompt, user_input, chat_history)

        if "error" in parsed_json:
            return parsed_json  # Return error dict if parsing failed

        # Optional: Validate the structure to ensure we have top-level "criteria"
        if "criteria" not in parsed_json:
            return {"error": "No 'criteria' field found in the JSON response."}

        # We assume the user might have numeric filters for certain columns
        # (Optionally do further validation here if needed)

        print("‚úÖ Debug: Successfully parsed JSON screener criteria.")
        return parsed_json
    
